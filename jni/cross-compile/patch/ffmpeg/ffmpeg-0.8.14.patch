diff -uNr ffmpeg-0.8.14/libavformat/applehttp.c ffmpeg-0.8.14.livetv/libavformat/applehttp.c
--- ffmpeg-0.8.14/libavformat/applehttp.c	2013-02-21 09:57:06.000000000 +0800
+++ ffmpeg-0.8.14.livetv/libavformat/applehttp.c	2013-05-22 12:49:07.606671416 +0800
@@ -98,6 +98,9 @@
     int cur_seq_no;
     int end_of_segment;
     int first_packet;
+    int64_t first_timestamp;
+    int64_t seek_timestamp;
+    int seek_flags;
 } AppleHTTPContext;
 
 static int read_chomp_line(AVIOContext *s, char *buf, int maxlen)
@@ -369,13 +372,23 @@
 
 restart:
     if (!v->input) {
-reload:
-        /* If this is a live stream and target_duration has elapsed since
+        /* If this is a live stream and the reload interval has elapsed since
          * the last playlist reload, reload the variant playlists now. */
+        int64_t reload_interval = v->n_segments > 0 ?
+                                  v->segments[v->n_segments - 1]->duration :
+                                  v->target_duration;
+        reload_interval *= 1000000;
+
+reload:
         if (!v->finished &&
-            av_gettime() - v->last_load_time >= v->target_duration*1000000 &&
-            (ret = parse_playlist(c, v->url, v, NULL)) < 0)
+            av_gettime() - v->last_load_time >= reload_interval) {
+            if ((ret = parse_playlist(c, v->url, v, NULL)) < 0)
                 return ret;
+            /* If we need to reload the playlist again below (if
+             * there's still no more segments), switch to a reload
+             * interval of half the target duration. */
+            reload_interval = v->target_duration * 500000;
+        }
         if (v->cur_seq_no < v->start_seq_no) {
             av_log(NULL, AV_LOG_WARNING,
                    "skipping %d segments ahead, expired from playlists\n",
@@ -386,7 +399,7 @@
             if (v->finished)
                 return AVERROR_EOF;
             while (av_gettime() - v->last_load_time <
-                   v->target_duration*1000000) {
+                   reload_interval) {
                 if (url_interrupt_cb())
                     return AVERROR_EXIT;
                 usleep(100*1000);
@@ -411,7 +424,7 @@
     c->end_of_segment = 1;
     c->cur_seq_no = v->cur_seq_no;
 
-    if (v->ctx) {
+    if (v->ctx && v->ctx->nb_streams) {
         v->needed = 0;
         for (i = v->stream_offset; i < v->stream_offset + v->ctx->nb_streams;
              i++) {
@@ -443,11 +456,12 @@
     /* If the playlist only contained variants, parse each individual
      * variant playlist. */
     if (c->n_variants > 1 || c->variants[0]->n_segments == 0) {
-        for (i = 0; i < c->n_variants; i++) {
-            struct variant *v = c->variants[i];
+		/* FIXME modify by juguofeng	2013-05-22 	just for CUTV playing */
+        //for (i = 0; i < c->n_variants; i++) {
+            struct variant *v = c->variants[0];
             if ((ret = parse_playlist(c, v->url, v, NULL)) < 0)
                 goto fail;
-        }
+        //}
     }
 
     if (c->variants[0]->n_segments == 0) {
@@ -494,8 +508,15 @@
         v->pb.seekable = 0;
         ret = av_probe_input_buffer(&v->pb, &in_fmt, v->segments[0]->url,
                                     NULL, 0, 0);
-        if (ret < 0)
+        if (ret < 0) {
+            /* Free the ctx - it isn't initialized properly at this point,
+             * so avformat_close_input shouldn't be called. If
+             * avformat_open_input fails below, it frees and zeros the
+             * context, so it doesn't need any special treatment like this. */
+            avformat_free_context(v->ctx);
+            v->ctx = NULL;
             goto fail;
+        }
         v->ctx->pb       = &v->pb;
         ret = avformat_open_input(&v->ctx, v->segments[0]->url, in_fmt, NULL);
         if (ret < 0)
@@ -518,6 +539,8 @@
     }
 
     c->first_packet = 1;
+    c->first_timestamp = AV_NOPTS_VALUE;
+    c->seek_timestamp = AV_NOPTS_VALUE;
 
     return 0;
 fail:
@@ -532,7 +555,7 @@
 
     /* Check if any new streams are needed */
     for (i = 0; i < c->n_variants; i++)
-        c->variants[i]->cur_needed = 0;;
+        c->variants[i]->cur_needed = 0;
 
     for (i = 0; i < s->nb_streams; i++) {
         AVStream *st = s->streams[i];
@@ -577,11 +600,44 @@
         /* Make sure we've got one buffered packet from each open variant
          * stream */
         if (var->needed && !var->pkt.data) {
-            ret = av_read_frame(var->ctx, &var->pkt);
-            if (ret < 0) {
-                if (!url_feof(&var->pb))
-                    return ret;
-                reset_packet(&var->pkt);
+            while (1) {
+                int64_t ts_diff;
+                ret = av_read_frame(var->ctx, &var->pkt);
+                if (ret < 0) {
+                    if (!url_feof(&var->pb)) {
+                        return ret;
+                    } else {
+                        if ((var->cur_seq_no - var->start_seq_no) == (var->n_segments)) {
+                            return AVERROR_EOF;
+                        }
+                    }
+                    reset_packet(&var->pkt);
+                } else {
+                    if (c->first_timestamp == AV_NOPTS_VALUE)
+                        c->first_timestamp = var->pkt.dts;
+                }
+
+                if (c->seek_timestamp == AV_NOPTS_VALUE)
+                    break;
+
+                if (var->pkt.dts == AV_NOPTS_VALUE) {
+                    c->seek_timestamp = AV_NOPTS_VALUE;
+                    break;
+                }
+
+                ts_diff = var->pkt.dts - c->seek_timestamp;
+                if (ts_diff >= 0) {
+                    if (c->seek_flags & AVSEEK_FLAG_ANY) {
+                        c->seek_timestamp = AV_NOPTS_VALUE;
+                        break;
+                    }
+
+                    /* Seek to keyframe */
+                    if (var->pkt.flags & AV_PKT_FLAG_KEY) {
+                        c->seek_timestamp = AV_NOPTS_VALUE;
+                        break;
+                    }
+                }
             }
         }
         /* Check if this stream has the packet with the lowest dts */
@@ -622,16 +678,27 @@
     if ((flags & AVSEEK_FLAG_BYTE) || !c->variants[0]->finished)
         return AVERROR(ENOSYS);
 
+    c->seek_timestamp = timestamp;
+    c->seek_flags = flags;
     timestamp = av_rescale_rnd(timestamp, 1, stream_index >= 0 ?
                                s->streams[stream_index]->time_base.den :
                                AV_TIME_BASE, flags & AVSEEK_FLAG_BACKWARD ?
                                AV_ROUND_DOWN : AV_ROUND_UP);
+    if (s->duration < c->seek_timestamp) {
+        c->seek_timestamp = AV_NOPTS_VALUE;
+        return AVERROR(EIO);
+    }
+
     ret = AVERROR(EIO);
     for (i = 0; i < c->n_variants; i++) {
         /* Reset reading */
         struct variant *var = c->variants[i];
-        int64_t pos = 0;
-        if (var->input) {
+        int64_t pos = c->first_timestamp == AV_NOPTS_VALUE ? 0 :
+                      av_rescale_rnd(c->first_timestamp, 1, stream_index >= 0 ?
+                               s->streams[stream_index]->time_base.den :
+                               AV_TIME_BASE, flags & AVSEEK_FLAG_BACKWARD ?
+                               AV_ROUND_DOWN : AV_ROUND_UP);
+         if (var->input) {
             ffurl_close(var->input);
             var->input = NULL;
         }
@@ -649,6 +716,8 @@
             }
             pos += var->segments[j]->duration;
         }
+        if (ret != 0)
+            c->seek_timestamp = AV_NOPTS_VALUE;
     }
     return ret;
 }
